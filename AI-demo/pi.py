#!/usr/bin/env python
# -*- encoding: utf-8 -*-
'''
@File    :   pi.py
@Time    :   2019/12/10 10:55:48
@Author  :   LiJu Tsang
@Version :   1.0
@Contact :   zengliju60@gmail.com,957790617@qq.com
@Desc    :   None
'''

# here put the import code
'''
蒙特卡罗算法
假如筐里有100个苹果，每次闭眼拿1个，要求挑出筐里最大的苹果。于
是我们首先随机拿1个，再随机拿1个与之对比，并留下大的那一个，接着
随机拿1个……每拿一次，留下的苹果都至少比上一次的大。拿的次数越多，
挑出的苹果就越大。不过，要想保证挑出框里最大的，只有将筐里的100个
苹果都拿光。这种挑苹果的办法，就属于蒙特卡罗算法——尽量找更符合目
标要求的，但不保证是最符合目标要求的。也就是说，蒙特卡罗算法是样本
越多，越能找到更佳的解决办法，但不保证是最佳的。
蒙特卡罗模拟小程序：计算圆周率
计算原理如图3.4.9所示，先画一个正方形及其内切圆，然后在这个正
方形内随机地画点，设点落在圆内的概率为 P ，则
P =圆面积÷正方形面积。通过获得圆面积来计算圆
周率： P =π R
2 /(2 R ×2 R )=π/4，即π=4 P 。
以下是程序算法步骤：
1. 将圆心设在直角坐标系原点，以 R 为半径作
圆，则第一象限的1/4圆面积为 Pi × R × R /4 ；
2. 作该1/4圆的外接正方形，4个顶点坐标分别
为（0，0）、（0， R ）、（ R ，0）、（ R ， R ），则该正
方形面积为 R × R ；
3. 随机取点（ X ， Y ），使得0≤ X ≤ R ，并且0≤ Y ≤ R ，即点在正方
形内；
4. 计算  X × X + Y × Y 的值，判断该值是否小于1 ；
5. 设所有点（也就是实验次数）的个数为 N ，落在1/4圆内的点（满足
第四步的点）的个数为 M ，则 P = M / N   于是 Pi =4× N / M 
'''

# -*- coding: utf-8 -*-
#蒙特卡洛模拟求Pi
import random
def M_C(num):
    count=0
    for i in range(1,num+1):
        X=random.uniform(0,1)
        Y=random.uniform(0,1)
        if X**2+Y**2<1:
            count+=1
    return 4.0*count/num

PI = M_C(999999)
print('Π:',PI)